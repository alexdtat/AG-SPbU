#include <iostream>

using namespace std;

int gcd (int a, unsigned int b){ // ф-ия, находящая НОД
    if (0 == b) return a;
    return gcd (b, a%b);
};

struct Rational{ // создание типа данных Rational
    int m;
    unsigned int n;
    Rational(int a, unsigned int b){
        m = a / gcd (a, b);
        n = b / gcd (a, b);
    }
    Rational (Rational &X){ // конструктор копий объектов типа Rational
        m = X.m;
        n = X.n;
    }
//    Rational &operator= (Rational &b){ // перегрузка оператора присвоения = для типа данных Rationa
//        this.m = b.m;
//        this.n = b.n;
//        return *this;
//    }

    Rational &operator*= (Rational &b){ // перегрузка оператора *= для типа данных Rational
        m *= b.m;
        n *= b.n;
        int g = gcd (m, n);
        m /= g;
        n /= g;
        return *this;
    }
    Rational &operator/= (Rational &b){ // перегрузка оператора /= для типа данных Rational
        m *= b.n;
        n *= b.m;
        int g = gcd (m, n);
        m /= g;
        n /= g;
        return *this;
    }
};



Rational operator* (Rational a, Rational &b){ // перегрузка оператора * для типа данных Rational
    a *= b;
    int g = gcd (a.m, a.n);
    a.m /= g;
    a.n /= g;
    return a;
};

Rational operator/ (Rational a, Rational &b){ // перегрузка оператора / для типа данных Rational
    a /= b;
    int g = gcd (a.m, a.n);
    a.m /= g;
    a.n /= g;
    return a;
};

bool operator> (Rational &a, Rational &b){ // перегрузка оператора > для типа данных Rational
    return (a.m * b.n > a.n * b.m);
};

bool operator<= (Rational &a, Rational &b){ // перегрузка оператора <= для типа данных Rational
    return !(a > b);
};

bool operator< (Rational &a, Rational &b){ // перегрузка оператора < для типа данных Rational
    return (a.m * b.n < a.n * b.m);
};

bool operator>= (Rational &a, Rational &b){ // перегрузка оператора >= для типа данных Rational
    return !(a < b);
};

bool operator== (Rational &a, Rational &b){ // перегрузка оператора == для типа данных Rational
    return ((a.m == b.m) && (a.n == b.n));
};

ostream& operator<< (std::ostream& out, const Rational &a){ // перегрузка оператора << выходного потока данных для типа данных Rational
    return out << a.m << "/" << a.n;
};

istream& operator>> (std::istream& in, Rational &a){ // перегрузка оператора >> входного потока данных для типа данных Rational
    in >> a.m >> a.n;
    int g = gcd (a.m, a.n);
    a.m /= g;
    a.n /= g;
    return in;
};

void testing_rational (Rational &num1, Rational &num2){ // метод для демонстрации различных операторов и свойств, определённых для Rational
    cout << "First number: " << num1 << '\n' << "Second number: " << num2 << '\n';
    cout << "Division (with / operator): (" << num1 << ") / (" << num2 << ") = " << num1/num2 << '\n';
    cout << "First number: " << num1 << '\n' << "Second number: " << num2 << '\n';
    cout << "Multiplication (with * operator): (" << num1 << ") * (" << num2 << ") = " << num1*num2 << '\n';
    cout << "First number: " << num1 << '\n' << "Second number: " << num2 << '\n';
    if (num1 > num2) cout << num1 << " > " << num2 << '\n';
    if (num1 >= num2) cout << num1 << " >= " << num2 << '\n';
    if (num1 == num2) cout << num1 << " = " << num2 << '\n';
    if (num1 <= num2) cout << num1 << " <= " << num2 << '\n';
    if (num1 < num2) cout << num1 << " < " << num2 << '\n';
    cout << "Multiplication (with *= operator): (" << num1;
    num1 *= num2;
    cout << ") * (" << num2 << ") = " << num1 << '\n';
    cout << "First number: " << num1 << '\n' << "Second number: " << num2 << '\n';
    cout << "Division (with /= operator): (" << num1;
    num1 /= num2;
    cout << ") / (" << num2 << ") = " << num1 << '\n';
    cout << "First number: " << num1 << '\n' << "Second number: " << num2 << '\n';
}

int main()
{
    Rational usnum1(1,1), usnum2(1,1);
    cout << "Input your first number:\n";
    cin >> usnum1;
    cout << "Input your second number:\n";
    cin >> usnum2;
    testing_rational(usnum1, usnum2);
    return 0;
}
